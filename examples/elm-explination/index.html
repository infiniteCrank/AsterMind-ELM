<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Extreme Learning Machine — JS Engineer Primer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root{
      --bg:#050c1f; --panel:#0b1633; --ink:#e5efff; --muted:#a7b8e8; --accent:#5ad1ff; --good:#6ee7a2; --warn:#facc15; --bad:#fb7185;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:radial-gradient(1200px 700px at 50% -200px,#0b1633 0%,#050c1f 55%,#020614 100%);
      color:var(--ink); font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }
    .app{display:flex; flex-direction:column; min-height:100vh;}
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:14px 16px; background:linear-gradient(180deg,rgba(90,209,255,0.12),rgba(90,209,255,0.0));
      border-bottom:1px solid #13244f;
    }
    header h1{font-size:1.05rem; margin:0; font-weight:600; letter-spacing:0.2px}
    .nav{display:flex; gap:8px;}
    button{
      background:#102043; color:var(--ink); border:1px solid #1f3570; border-radius:10px; padding:8px 12px; cursor:pointer;
    }
    button:hover{background:#12265a}
    button[disabled]{opacity:.6; cursor:not-allowed}
    main{flex:1; display:flex; justify-content:center; padding:16px}
    .slide{
      width:min(1100px,100%); display:grid; grid-template-columns: 1.1fr .9fr; gap:16px;
      padding:16px; background:rgba(7,16,41,0.66); border:1px solid #14244e; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.30);
    }
    .left, .right{min-height:380px; background:rgba(8,19,44,0.72); border:1px solid #182d61; border-radius:14px; overflow:hidden; position:relative}
    .panel{padding:14px 14px 10px 14px; height:100%; display:flex; flex-direction:column; gap:10px;}
    h2{margin:0 0 6px 0; font-size:1.05rem}
    p{margin:.25rem 0; color:var(--muted); line-height:1.35}
    label{font-size:.9rem; color:var(--muted)}
    select,input[type=range]{width:100%}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .chip{padding:4px 8px; border:1px solid #203a7c; border-radius:999px; font-size:.8rem; color:#bcd0ff; background:#0c1a3d}
    .canvasWrap{flex:1; border:1px dashed #253f85; border-radius:10px; overflow:hidden; background:#071332}
    canvas{display:block; width:100%; height:100%}
    .footerBar{display:flex; gap:10px; justify-content:flex-end; margin-top:8px}
    .code{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; background:#0c1a3d; border:1px solid #203a7c; border-radius:8px; padding:8px; font-size:.88rem; color:#cfe1ff; overflow:auto}
    .note{font-size:.85rem; color:#93a9e8}
    .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}
    @media (max-width: 980px){
      .slide{grid-template-columns: 1fr; }
      .left,.right{min-height:300px}
    }
        [hidden] { 
      display: none !important;
    }
    /* Slide 2 heatmap extras */
    .canvasWrap { position: relative; }            /* for tooltip positioning */
    .heat-legend{
      display:flex; align-items:center; gap:8px;
      margin-top:6px; font-size:.85rem; color:var(--muted);
    }
    .legend-bar{
      width:160px; height:10px; border-radius:999px; border:1px solid #203a7c;
      background: linear-gradient(90deg, hsla(0,90%,60%,.85), hsla(210,30%,20%,.15) 50%, hsla(200,90%,60%,.85));
    }
    .encode-tip{
      position:absolute; top:0; left:0; transform: translate(8px, -28px);
      background:#0c1a3d; border:1px solid #203a7c; padding:4px 6px; border-radius:6px;
      font-size:.8rem; color:#cfe1ff; display:none; pointer-events:none; white-space:nowrap;
    }
    /* Slide 3 legend + tooltips */
    .heat-legend{
      display:flex; align-items:center; gap:10px;
      margin-top:8px; font-size:.85rem; color:var(--muted);
    }
    .legend-chip{ padding:2px 8px; border:1px solid #203a7c; border-radius:999px; }
    .legend-bar{
      width:160px; height:10px; border-radius:999px; border:1px solid #203a7c;
      background: linear-gradient(90deg, hsla(0,90%,60%,.85), hsla(210,30%,20%,.15) 50%, hsla(200,90%,60%,.85));
    }
    .hidden-tip{
      position:absolute; top:0; left:0;
      transform: translate(8px,-28px);
      background:#0c1a3d; border:1px solid #203a7c; padding:4px 6px; border-radius:6px;
      font-size:.8rem; color:#cfe1ff; display:none; pointer-events:none; white-space:nowrap;
    }

    /* Let each slide have a top hero row that spans both columns */
    .slide{
      grid-template-rows: auto 1fr;       /* hero (cap) + content */
    }

    /* Cap image */
    .slide > .hero{
      grid-column: 1 / -1;
      height: clamp(500px, 28vh, 380px);  /* tweak to taste */
      border-radius: 14px;
      border: 1px solid #182d61;
      background-position: center 50%;    /* baseline anchor */
      background-repeat: no-repeat;
      background-size: cover;             /* needed for the parallax effect */
      position: relative;
      overflow: hidden;
      margin-bottom: 10px;
      box-shadow: 0 12px 30px rgba(0,0,0,.28);
      will-change: background-position;   /* smoother parallax */
    }

    /* Optional overlay & caption (keeps text legible) */
    .slide > .hero::after{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(180deg, rgba(5,12,31,0) 0%, rgba(5,12,31,.25) 60%, rgba(5,12,31,.55) 100%);
      pointer-events:none;
    }
    .hero .caption{
      position:absolute; left:12px; bottom:10px;
      font-size:.9rem; color:#cfe1ff; opacity:.95;
      background: rgba(12,26,61,.55);
      border:1px solid #203a7c;
      padding:4px 8px; border-radius:8px;
    }

    /* Helpful if your page gets a momentum scroll */
    html, body { scroll-behavior: smooth; }

  </style>
</head>
<body>
<div class="app">
  <header>
    <h1>Extreme Learning Machines — a visual primer for JS engineers</h1>
    <div class="nav">
      <button id="prevBtn">◀ Back</button>
      <div class="chip" id="slideLabel">Slide 1 / 5</div>
      <button id="nextBtn">Next ▶</button>
    </div>
  </header>

  <main>
    <!-- INTRO (new) -->
    <section class="slide" id="slideIntro" data-stage="intro" hidden>
      <figure class="hero" data-hero="images/slide1.png">
        <div class="caption">The “skip the hidden-layer training” idea</div>
      </figure>
      <div class="left">
        <div class="panel">
          <h2>Extreme Learning Machines — The “skip training the hidden layer” idea</h2>
          <div class="intro-copy">
            <p>In the mid-2000s, machine learning was in a very different place than it is today.
            Deep learning was starting to get attention, but it was still this… mysterious, heavy beast. If you wanted to train a neural network, you had to set up long loops of backpropagation. You had to carefully tune learning rates, watch your gradients explode or vanish, and pray your model converged.
            And it was slow. Painfully slow. Imagine trying to write modern React code, but every time you made a change, you had to recompile your whole project from scratch and wait hours just to see if it worked. That’s what training felt like.</p>

            <p>Then along comes Guang-Bin Huang.
            And he asks a question that, to most people at the time, sounded like madness. What if we didn’t train the hidden layers at all?
            Let me pause here. <em>[look around the audience]</em>
            To engineers in the room, this is like saying: what if we shipped production code without writing any unit tests? It goes against the grain. The hidden layers are where the magic happens, right? Why on earth would you skip training them?</p>
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
           <p>But Huang’s insight was bold and simple.
            He said: let’s just randomize the hidden layer. Flip a bunch of coins, assign random weights. Then, don’t touch them.
            Instead, let’s focus all our effort on solving the output layer in a single step. Mathematically, this meant using something called the pseudoinverse — basically, linear algebra’s version of a one-shot “give me the best fit.”
            So instead of looping for hours, you could train a neural net in seconds.</p>

            <p>Think about that in JavaScript terms. It’s like discovering that instead of writing your own state management system, you could just import Redux Toolkit or Zustand and be done in one line. Or instead of writing your own DOM diffing algorithm, you could just use React.
            It’s that same moment of: wait… this can’t be that simple… can it?
            And yet, it worked.</p>

            <p>Out of that rebellious thought — skipping the ‘sacred’ training of hidden layers — was born the Extreme Learning Machine.
            Now, at first, people dismissed it. It was too weird, too outside the norms. Backpropagation was the hammer, and every problem looked like a nail.
            But slowly, folks started to realize: there’s something here. ELMs are not just a toy. They’re fast. They’re simple. They can actually solve problems where speed and efficiency matter more than absolute state-of-the-art accuracy.
            And that’s why we’re here today. To dig into this oddball invention and ask: can it help us in the world of web apps, browsers, and JavaScript engineering?</p>
          
        </div>
      </div>
    </section>

    <!-- SLIDE 1 -->
    <section class="slide" id="slide1" data-stage="neuron" hidden>
      <div class="left">
        <div class="panel">
          <h2>1) Single Neuron + Activations</h2>
          <p>Adjust <em>w</em> and <em>b</em>, choose an activation, and watch <code>y = g(w·x + b)</code> change in real time.</p>
          <div class="row">
            <div style="flex:1">
              <label>Activation</label>
              <select id="actSelect">
                <option value="relu">ReLU</option>
                <option value="leakyRelu">LeakyReLU</option>
                <option value="sigmoid">Sigmoid</option>
                <option value="tanh">tanh</option>
              </select>
            </div>
            <div class="chip">Live chart</div>
          </div>
          <div class="kv"><label>Weight (w)</label><span id="wVal">1.00</span></div>
          <input id="wRange" type="range" min="-5" max="5" step="0.05" value="1">
          <div class="kv"><label>Bias (b)</label><span id="bVal">0.00</span></div>
          <input id="bRange" type="range" min="-5" max="5" step="0.05" value="0">

          <div class="canvasWrap" style="height:260px">
            <canvas id="neuronCanvas"></canvas>
          </div>
          <div class="note">“Affine” just means: compute <code>z = w·x + b</code> (a line), then bend it with an activation <code>g(z)</code>.</div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Plain English</h2>
          <p>A neuron is a little function that takes a number, nudges it (<em>w</em> and <em>b</em>), then runs it through a squiggle (activation).</p>
          <p>Try negative <strong>w</strong> with <strong>ReLU</strong> vs <strong>tanh</strong> to feel different shapes.</p>
          <div class="code"><pre>// y = g(w·x + b)
const z = w * x + b;
const y = activation(z);</pre></div>
        </div>
      </div>
    </section>

    <!-- SLIDE 2 -->
    <section class="slide" id="slide2" data-stage="input" hidden>
      <div class="left">
        <div class="panel">
          <h2>2) Input Encoding (AG-News snippet)</h2>
          <p>Select a training row. We’ll vectorize the text and render a small feature heatmap.</p>
          <div class="row">
            <select id="rowSelect" style="flex:1"></select>
            <button id="encodeBtn">Encode →</button>
          </div>
          <div class="canvasWrap" style="height:260px; position:relative">
            <canvas id="encodeCanvas"></canvas>
          </div>
          <div id="tokensOut" class="code" style="min-height:80px"></div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Plain English</h2>
          <p>Text becomes numbers (features). Each little square is one number. <span class="note">Blue = positive, red = negative, brighter = larger magnitude.</span></p>
          <p>ELM doesn’t care how you encode—TF-IDF, bag-of-words, etc. We just need a vector so the hidden layer can project it.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE 3 -->
    <section class="slide" id="slide3" data-stage="hidden" hidden>
      <div class="left">
        <div class="panel">
          <h2>3) Hidden Layer (Random &amp; Shuffle)</h2>
          <p>Random projection: <code>H = g(X·W + b)</code>. Shuffle to reseed the hidden layer.</p>
          <div class="row">
            <div style="flex:1">
              <label>Hidden size</label>
              <!-- Slide 3 control -->
              <input id="hiddenSize" type="range" min="4" max="1024" step="1" value="32">
              <div class="note"><span id="hiddenSizeVal">32</span> neurons (downsampled for display if huge)</div>
            </div>
            <button id="shuffleBtn" title="Reseed hidden layer">Shuffle Hidden</button>
            <button id="previewHBtn" title="Project current x">Project H = g(X·W + b)</button>
          </div>
          <div class="canvasWrap" style="height:260px; position:relative">
            <canvas id="hiddenCanvas"></canvas>
          </div>
          <div id="WPreview" class="code" style="min-height:80px"></div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Plain English</h2>
          <p>Imagine dropping a <em>random grid</em> on a messy city so you can say “row 3, col 5”. That’s what the hidden layer does for your data.</p>
          <p>Each heatmap <em>row</em> = a hidden neuron. Each <em>column</em> = an input feature. Colors show sign &amp; magnitude of <code>W[i,j]</code>.</p>
          <p>The green bars show <code>H = g(Wx+b)</code> for the currently encoded text. More hidden neurons = more random features to catch patterns.</p>
          <p>The numbers box below is an <strong>8×8 slice of W</strong> so you can see real values.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE 4 -->
    <section class="slide" id="slide4" data-stage="output" hidden>
      <div class="left">
        <div class="panel">
          <h2>4) Output Layer (Pseudoinverse Solve)</h2>
          <p>We solve <code>Hβ ≈ Y</code> in one shot (pseudoinverse). Then we predict for a selected row.</p>
          <!-- Slide 4 buttons (add two on the right) -->
          <div class="row">
            <button id="trainBtn">Train on snippet</button>
            <button id="predictBtn" title="Train first">Predict selected row</button>
            <span style="flex:1"></span>
            <button id="downloadBtn" title="Save W,b,β and basis">Download model</button>
            <button id="resetBtn" title="Clear model & basis">Reset</button>
          </div>

          <div id="solveOut" class="code" style="min-height:100px">Waiting…</div>
          <div class="canvasWrap" style="height:220px">
            <canvas id="betaCanvas"></canvas>
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Plain English</h2>
          <p>The final layer is like a GPS: once the random coordinates exist, we draw a straight boundary there. No epochs, just a single solve.</p>
          <div class="code"><pre>// Predict
const Hx = g(x·W + b);
const logits = Hx · β;          // class scores
// (softmax if you want probabilities)</pre></div>
          <p class="note">Speed is the point. It’s like switching from a long webpack build to an instant esbuild—train in a blink.</p>
        </div>
      </div>
    </section>
  </main>

  <div style="padding:8px 16px; display:flex; gap:8px; align-items:center; justify-content:space-between;">
    <div id="status" class="note">Worker: <span id="workerStatus">connecting…</span></div>
    <div class="footerBar">
      <!-- Buttons are generated dynamically by JS to match slide count -->
      <button>1</button><button>2</button><button>3</button><button>4</button>
    </div>
  </div>
</div>

<!-- App script -->
<script src="elm-demo.js"></script>
</body>
</html>
