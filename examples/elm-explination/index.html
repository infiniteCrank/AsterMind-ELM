<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Extreme Learning Machine — JS Engineer Primer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root{
      --bg:#050c1f; --panel:#0b1633; --ink:#e5efff; --muted:#a7b8e8; --accent:#5ad1ff; --good:#6ee7a2; --warn:#facc15; --bad:#fb7185;
      --chip:#0c1a3d; --chip-border:#203a7c;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:radial-gradient(1200px 700px at 50% -200px,#0b1633 0%,#050c1f 55%,#020614 100%);
      color:var(--ink); font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }
    .app{display:flex; flex-direction:column; min-height:100vh;}
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:14px 16px; background:linear-gradient(180deg,rgba(90,209,255,0.12),rgba(90,209,255,0.0));
      border-bottom:1px solid #13244f;
      position:sticky; top:0; z-index:10;
    }
    header h1{font-size:1.05rem; margin:0; font-weight:600; letter-spacing:0.2px}
    .nav{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    button{
      background:#102043; color:var(--ink); border:1px solid #1f3570; border-radius:10px; padding:8px 12px; cursor:pointer;
    }
    button:hover{background:#12265a}
    button[disabled]{opacity:.6; cursor:not-allowed}

    /* Mini-map */
    .minimap{
      display:flex; gap:6px; align-items:center; flex-wrap:wrap;
      padding:8px 16px; border-top:1px solid #13244f; border-bottom:1px solid #13244f;
      background:linear-gradient(180deg,rgba(90,209,255,0.06),rgba(90,209,255,0.0));
    }
    .stage-chip{
      padding:4px 10px; border:1px solid var(--chip-border); border-radius:999px;
      background:var(--chip); font-size:.8rem; color:#bcd0ff; opacity:.75; white-space:nowrap;
    }
    .stage-chip.active{opacity:1; border-color:#3b66d1; color:#eaf2ff; box-shadow:0 0 0 1px rgba(90,209,255,.25) inset;}
    .progress{
      height:6px; flex:1; border-radius:999px; background:#0b1633; border:1px solid #1f3570; position:relative; min-width:140px;
    }
    .progress > .bar{
      position:absolute; top:-1px; left:-1px; height:calc(100% + 2px); width:0%;
      background:linear-gradient(90deg, #2a64ff, #5ad1ff);
      border-radius:999px;
    }

    main{flex:1; display:flex; justify-content:center; padding:16px}
    .slide{
      width:min(1100px,100%); display:grid; grid-template-columns: 1.1fr .9fr; gap:16px;
      padding:16px; background:rgba(7,16,41,0.66); border:1px solid #14244e; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.30);
      grid-template-rows: auto 1fr; /* hero + content */
    }
    .left, .right{min-height:380px; background:rgba(8,19,44,0.72); border:1px solid #182d61; border-radius:14px; overflow:hidden; position:relative}
    .panel{padding:14px 14px 10px 14px; height:100%; display:flex; flex-direction:column; gap:10px;}
    h2{margin:0 0 6px 0; font-size:1.05rem}
    p{margin:.25rem 0; color:var(--muted); line-height:1.35}
    ul,ol{margin:.4rem 0 .6rem 1.1rem; color:var(--muted)}
    label{font-size:.9rem; color:var(--muted)}
    select,input[type=range]{width:100%}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .chip{padding:4px 8px; border:1px solid #203a7c; border-radius:999px; font-size:.8rem; color:#bcd0ff; background:#0c1a3d}
    .canvasWrap{flex:1; border:1px dashed #253f85; border-radius:10px; overflow:hidden; background:#071332}
    canvas{display:block; width:100%; height:100%}
    .footerBar{display:flex; gap:10px; justify-content:flex-end; margin-top:8px; flex-wrap:wrap}
    .code{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; background:#0c1a3d; border:1px solid #203a7c; border-radius:8px; padding:8px; font-size:.88rem; color:#cfe1ff; overflow:auto}
    .note{font-size:.85rem; color:#93a9e8}
    .notes{
      margin-top:auto; border-top:1px dashed #243f86; padding-top:8px; font-size:.88rem; color:#cfe1ff; display:none;
      background:rgba(12,26,61,.35); border-radius:8px; padding:10px; line-height:1.35;
    }
    body.show-notes .notes{display:block}
    .notes .label{font-weight:600; color:#eaf2ff; opacity:.9; display:block; margin-bottom:4px;}

    @media (max-width: 980px){
      .slide{grid-template-columns: 1fr; }
      .left,.right{min-height:300px}
      .minimap{gap:8px}
    }
    [hidden]{display:none !important;}

    /* Hero */
    .slide > .hero{
      grid-column: 1 / -1;
      height: clamp(320px, 45vh, 600px);
      border-radius: 14px;
      border: 1px solid #182d61;
      background: none;
      display: grid; place-items: center;
      position: relative; overflow: hidden; margin-bottom: 10px;
      box-shadow: 0 12px 30px rgba(0,0,0,.28);
    }
    .slide > .hero img{
      width: 100%; height: 100%; object-fit: contain;
    }
    .hero .caption{
      position:absolute; left:12px; bottom:10px;
      font-size:.9rem; color:#cfe1ff; opacity:.95;
      background: rgba(12,26,61,.55);
      border:1px solid #203a7c;
      padding:4px 8px; border-radius:8px;
    }

    /* Tooltip positioning tweaks: rely on left/top from JS, no transform */
    .encode-tip,.hidden-tip,.bp-tip{
      position:absolute;
      top:0;
      left:0;
      transform:none;
      background:#0c1a3d;
      border:1px solid #203a7c;
      padding:4px 6px;
      border-radius:6px;
      font-size:.8rem;
      color:#cfe1ff;
      display:none;
      pointer-events:none;
      white-space:nowrap;
      z-index:10; /* ensure above canvas */
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <h1>Extreme Learning Machines — a visual primer for JS engineers</h1>
    <div class="nav">
      <button id="prevBtn">◀ Back</button>
      <div class="chip" id="slideLabel">Slide 1 / 12</div>
      <button id="nextBtn">Next ▶</button>
      <button id="notesToggle" title="Show/Hide speaker notes">Notes</button>
    </div>
  </header>

  <!-- Mini-map -->
  <div class="minimap">
    <div class="stage-chip" data-stagechip="overview">Overview</div>
    <div class="stage-chip" data-stagechip="neuron">Neuron</div>
    <div class="stage-chip" data-stagechip="input">Vectorize</div>
    <div class="stage-chip" data-stagechip="backprop">Backprop</div>
    <div class="stage-chip" data-stagechip="huang">Huang</div>
    <div class="stage-chip" data-stagechip="grid">Random Grid</div>
    <div class="stage-chip" data-stagechip="gps">GPS/Pinv</div>
    <div class="stage-chip" data-stagechip="why">Why Random</div>
    <div class="stage-chip" data-stagechip="hidden">Hidden</div>
    <div class="stage-chip" data-stagechip="output">One-shot</div>
    <div class="stage-chip" data-stagechip="compare">Compare</div>
    <div class="stage-chip" data-stagechip="predict">Predict</div>
    <div class="progress"><div class="bar" id="progressBar"></div></div>
  </div>

  <main>

    <!-- SLIDE 1: OVERVIEW -->
    <section class="slide" id="slide0" data-stage="overview">
      <figure class="hero">
        <img src="images/intro.png" alt="ELM intro artwork" />
        <div class="caption">What we’ll cover</div>
      </figure>
      <div class="left">
        <div class="panel">
          <h2>What we’ll learn</h2>
          <ul>
            <li><strong>Neurons:</strong> weight, bias, activation function.</li>
            <li><strong>Vectorization:</strong> turning text into numeric features.</li>
            <li><strong>Why training is hard:</strong> too many parameters to tune.</li>
            <li><strong>Backprop (classic):</strong> iterative updates in loops.</li>
            <li><strong>ELM (shortcut):</strong> random hidden layer + one-shot solve.</li>
            <li><strong>Prediction:</strong> run the trained model on a sample.</li>
          </ul>
          <p class="note">We’ll keep it JavaScript-friendly: sliders, canvases, and small code snippets.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Open with the promise: ELMs let us train in seconds. Point at the minimap and set expectations for the flow.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Roadmap</h2>
          <ol>
            <li>Neuron basics</li>
            <li>Neuron demo</li>
            <li>Text → vector</li>
            <li>Backprop loops</li>
            <li>Huang’s question</li>
            <li>Random grid intuition</li>
            <li>GPS/pseudoinverse</li>
            <li>Why randomness helps</li>
            <li>Random hidden &amp; project</li>
            <li>ELM one-shot training</li>
            <li>Backprop vs ELM</li>
            <li>Prediction</li>
          </ol>
          <div class="notes"><span class="label">Speaker notes</span>
            Mention we’ll avoid heavy math; we’ll visualize the ideas and keep code minimal.
          </div>
        </div>
      </div>
    </section>

    <!-- SLIDE 2: NEURON INTRO -->
    <section class="slide" id="slideIntroNeuron" data-stage="neuron">
      <figure class="hero" data-hero="images/intro.png">
        <div class="caption">Neurons are small functions</div>
      </figure>
      <div class="left">
        <div class="panel">
          <h2>Neurons in plain JS</h2>
          <p>A neuron takes a number <code>x</code>, computes <code>z = w*x + b</code>, then applies an <em>activation function</em> (e.g., ReLU, <code>tanh</code>): <code>y = g(z)</code>.</p>
          <div class="code"><pre>// one neuron
const z = w * x + b;      // affine transform
const y = activation(z);  // apply nonlinearity</pre></div>
          <p class="note">Networks are lots of these composed.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Reinforce “affine then nonlinearity.” We’ll visualize next.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Vocabulary</h2>
          <ul>
            <li><strong>w</strong> (weight): how strongly x pushes output</li>
            <li><strong>b</strong> (bias): constant offset</li>
            <li><strong>activation function</strong>: controlled nonlinearity</li>
          </ul>
          <p class="note">Next: play with a single neuron live.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Keep the terms crisp; we’ll compare activations shortly.
          </div>
        </div>
      </div>
    </section>

    <!-- SLIDE 3: NEURON DEMO -->
    <section class="slide" id="slide1" data-stage="neuron">
      <div class="left">
        <div class="panel">
          <h2>Neuron demo</h2>
          <p>Adjust <em>w</em> and <em>b</em>, choose an activation, and watch <code>y = g(w·x + b)</code>.</p>
          <div class="row">
            <div style="flex:1">
              <label>Activation</label>
              <select id="actSelect">
                <option value="relu">ReLU</option>
                <option value="leakyRelu">LeakyReLU</option>
                <option value="sigmoid">Sigmoid</option>
                <option value="tanh">tanh</option>
              </select>
            </div>
            <div class="chip">Live chart</div>
          </div>
          <div class="kv"><label>Weight (w)</label><span id="wVal">1.00</span></div>
          <input id="wRange" type="range" min="-5" max="5" step="0.05" value="1">
          <div class="kv"><label>Bias (b)</label><span id="bVal">0.00</span></div>
          <input id="bRange" type="range" min="-5" max="5" step="0.05" value="0">
          <div class="canvasWrap" style="height:260px"><canvas id="neuronCanvas"></canvas></div>
          <div class="note">“Affine” = compute <code>z = w·x + b</code>, then apply <code>g(z)</code>.</div>
          <div class="notes"><span class="label">Speaker notes</span>
            Try negative w; compare ReLU vs tanh; highlight clipping vs smoothness.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Try</h2>
          <ul>
            <li>Set <strong>w = -2</strong>, <strong>b = 0.5</strong></li>
            <li>Toggle ReLU ↔︎ tanh and observe shape changes</li>
          </ul>
          <div class="code"><pre>// y = g(w·x + b)
const z = w * x + b;
const y = activation(z);</pre></div>
          <div class="notes"><span class="label">Speaker notes</span>
            Keep this brisk; we’re heading toward why training is hard.
          </div>
        </div>
      </div>
    </section>

    <!-- SLIDE 4: VECTORIZATION -->
    <section class="slide" id="slide2" data-stage="input">
      <div class="left">
        <div class="panel">
          <h2>Vectorization (text → numbers)</h2>
          <p>Select a row. We’ll encode text to a feature vector and draw a mini heatmap.</p>
          <div class="row">
            <select id="rowSelect" style="flex:1"></select>
            <button id="encodeBtn">Encode text</button>
          </div>
          <div class="canvasWrap" style="height:260px; position:relative">
            <canvas id="encodeCanvas"></canvas>
          </div>
          <div id="tokensOut" class="code" style="min-height:80px"></div>
          <div class="notes"><span class="label">Speaker notes</span>
            Any reasonable encoding works for ELM; we just need a vector (TF-IDF or fallback).
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Plain English</h2>
          <p>Text → numbers (features). Each square is one number. <span class="note">Blue = positive, red = negative, brighter = larger magnitude.</span></p>
          <p>ELM only needs a numeric vector; the specific encoder is flexible.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE 5: WHY HAND TUNING IS HARD → BACKPROP -->
    <section class="slide" id="slideBP" data-stage="backprop">
      <div class="left">
        <div class="panel">
          <h2>Why manual tuning doesn’t scale</h2>
          <p>Real networks have many parameters—impossible to tweak by hand.</p>
          <p><strong>Backpropagation</strong> automates tuning in loops: measure error → nudge weights → repeat.</p>
          <div class="kv"><label>Learning rate</label><span id="bpLRVal">0.20</span></div>
          <input id="bpLR" type="range" min="0.01" max="1" step="0.01" value="0.20">
          <div class="canvasWrap" style="height:260px; position:relative">
            <canvas id="bpCanvas"></canvas>
          </div>
          <div class="note">Visual mock: weights wiggle; loss trends down.</div>
          <div class="notes"><span class="label">Speaker notes</span>
            Call out “too high LR = noisy; too low = slow.” Set up the contrast with ELM.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>What to look for</h2>
          <ul>
            <li>Left heatmap: hidden weights changing</li>
            <li>Right chart: loss trending down</li>
            <li>LR too high → noisy; too low → sluggish</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- SLIDE 6: HUANG'S QUESTION -->
    <section class="slide" id="slideHuang" data-stage="huang">
      <figure class="hero"><div class="caption">The bold question</div></figure>
      <div class="left">
        <div class="panel">
          <h2>Then along comes Guang-Bin Huang</h2>
          <p><em>What if we didn’t train the hidden layers at all?</em></p>
          <p>To many engineers, that sounds like shipping production code without unit tests. Hidden layers are where the magic happens—so why skip training them?</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Pause, look around. Let the “no hidden training” line sit. Invite skepticism.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>The insight</h2>
          <p>Randomize the hidden layer once (weights &amp; biases), then never touch it.</p>
          <p>Focus all effort on solving the output layer in one step with the Moore–Penrose pseudoinverse.</p>
          <p class="note">Minutes or hours of loops → seconds.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE 7: RANDOM GRID ANALOGY -->
    <section class="slide" id="slideGrid" data-stage="grid">
      <figure class="hero"><div class="caption">Random coordinates, useful structure</div></figure>
      <div class="left">
        <div class="panel">
          <h2>The city from above</h2>
          <p>From a skyscraper, the city looks messy—twisting streets, odd angles. Hard to give directions.</p>
          <p>Drop a <strong>random grid</strong> on top. It won’t match perfectly, but now you can say: “Café at row 3, col 5.” The grid isn’t smart—but it’s a reference system.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Gesture with hands as a grid overlay; “it’s not perfect, it’s useful”.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>ELM mapping</h2>
          <p>The hidden layer is that grid: it projects messy, high-dimensional data into random coordinates.</p>
          <p><code>H = g(X·W + b)</code></p>
          <p class="note">Once you have coordinates, organization gets simpler.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE 8: GPS / PSEUDOINVERSE -->
    <section class="slide" id="slideGPS" data-stage="gps">
      <figure class="hero"><div class="caption">One solve, like GPS routing</div></figure>
      <div class="left">
        <div class="panel">
          <h2>Output layer as GPS</h2>
          <p>With coordinates in hand, navigation is easy: straight lines in grid space. The output layer is the GPS: map random coordinates to labels in one exact step.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Promise: no epochs. We’ll compute β in a single calculation.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>The math idea</h2>
          <p>Use the <strong>Moore–Penrose pseudoinverse</strong> to solve <code>Hβ ≈ Y</code>.</p>
          <p>Think of it like <code>Array.prototype.reduce()</code> for optimization: push inputs &amp; labels through, get the best output weights <code>β</code>.</p>
          <p class="note">No gradient descent loops. One solve.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE 9: WHY RANDOMNESS WORKS -->
    <section class="slide" id="slideWhy" data-stage="why">
      <figure class="hero"><div class="caption">Unfold the data</div></figure>
      <div class="left">
        <div class="panel">
          <h2>Why randomness helps</h2>
          <p>Raw input space is often not linearly separable. Random projection to a higher-dimensional space can make separation easier—like unfolding a crumpled paper ball onto a plane.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            “Higher dimension → simpler boundaries.” Mention regularization briefly.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>ELM recipe</h2>
          <ol>
            <li>Project inputs with a randomized hidden layer to get <code>H</code>.</li>
            <li>Solve a linear model once for <code>β</code> so <code>Hβ ≈ Y</code>.</li>
          </ol>
          <p class="note">Surprisingly strong with enough hidden units + sensible ridge.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE 10: HIDDEN LAYER (random W,b + project H) -->
    <section class="slide" id="slideHidden" data-stage="hidden">
      <div class="left">
        <div class="panel">
          <h2>Hidden layer (Random &amp; Project)</h2>
          <p>Random projection: <code>H = g(X·W + b)</code>. Reseed the hidden layer; project the currently encoded row.</p>
          <div class="row">
            <span class="chip">Hidden size</span>
            <input id="hiddenSizeHL" type="range" min="4" max="1024" step="1" value="32" style="flex:1">
            <span class="note" id="hiddenSizeHLVal">32</span>
            <button id="shuffleBtnHL" title="Reseed W,b">Reseed hidden</button>
            <button id="previewHBtnHL" title="Project current x">Project H</button>
          </div>
          <div class="canvasWrap" style="height:260px; position:relative">
            <canvas id="hiddenCanvas"></canvas>
            <div class="hidden-tip"></div>
          </div>
          <div id="WPreview" class="code" style="min-height:80px"></div>
          <div class="notes"><span class="label">Speaker notes</span>
            Show W heatmap, then project a row to visualize H bars.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>What you’re seeing</h2>
          <p>Heatmap: rows = hidden neurons; cols = input features; color = sign &amp; magnitude of <code>W[i,j]</code>. Bars on right show <code>H = g(Wx + b)</code> for the selected text.</p>
          <p class="note">Tip: encode on the previous slide, then project.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE 11: ELM TRAINING (ONE SHOT) -->
    <section class="slide" id="slide4" data-stage="output">
      <div class="left">
        <div class="panel">
          <h2>ELM: random hidden + one-shot solve</h2>
          <p>We solve <code>Hβ ≈ Y</code> once (pseudoinverse / ridge). No loops.</p>
          <div class="row">
            <button id="trainBtn">Train (one shot)</button>
            <span class="chip">Hidden size</span>
            <input id="hiddenSize" type="range" min="4" max="1024" step="1" value="32" style="flex:1">
            <span class="note" id="hiddenSizeVal">32</span>
            <span style="flex:1"></span>
            <button id="downloadBtn" title="Save W,b,β and basis">Export model</button>
            <button id="resetBtn" title="Clear model & basis">Clear &amp; reset</button>
          </div>
          <div id="solveOut" class="code" style="min-height:100px">Waiting…</div>
          <div class="canvasWrap" style="height:220px">
            <canvas id="betaCanvas"></canvas>
          </div>
          <div class="notes"><span class="label">Speaker notes</span>
            Call out dimensions H (n×h), Y (n×k), β (h×k). Mention ridge.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Plain English</h2>
          <p>Random hidden features give coordinates. We draw a straight separator there. Done.</p>
          <p class="note">The shortcut: one solve vs many backprop loops.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE 12: BACKPROP VS ELM -->
    <section class="slide" id="slideCompare" data-stage="compare">
      <figure class="hero"><div class="caption">Two different mindsets</div></figure>
      <div class="left">
        <div class="panel">
          <h2>Backprop</h2>
          <p>Like sculpting a custom key for a lock: chip, test, adjust—many iterations until it fits.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Emphasize control/fidelity, but cost is time and tuning.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>ELM</h2>
          <p>Like trying a keyring of random keys (random hidden features). One fits; keep it by solving the output weights once.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Great default for fast baselines, prototyping, or small/medium tasks.
          </div>
        </div>
      </div>
    </section>

    <!-- SLIDE 13: PREDICTION -->
    <section class="slide" id="slidePred" data-stage="predict">
      <div class="left">
        <div class="panel">
          <h2>Prediction demo</h2>
          <p>Pick a row and run the trained model.</p>
          <div class="row">
            <select id="predRowSelect" style="flex:1"></select>
            <button id="predictBtn" title="Train first" disabled>Predict</button>
          </div>
          <div id="predOut" class="code" style="min-height:120px">Train on the previous slide, then predict.</div>
          <div class="notes"><span class="label">Speaker notes</span>
            Read out Predicted vs Truth and probabilities; note ✓/✗.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Reading the result</h2>
          <p><strong>Predicted label</strong>, ground truth, and per-class probabilities.</p>
          <p class="note">If the truth exists in the sample, we’ll mark ✓ or ✗.</p>
        </div>
      </div>
    </section>

  </main>

  <div style="padding:8px 16px; display:flex; gap:8px; align-items:center; justify-content:space-between;">
    <div id="status" class="note">Worker: <span id="workerStatus">connecting…</span></div>
    <div class="footerBar">
      <!-- Buttons auto-generated by JS -->
    </div>
  </div>
</div>

<script src="elm-demo.js"></script>
</body>
</html>
