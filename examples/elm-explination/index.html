<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Extreme Learning Machine — JS Engineer Primer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root{
      --bg:#050c1f; --panel:#0b1633; --ink:#e5efff; --muted:#a7b8e8; --accent:#5ad1ff; --good:#6ee7a2; --warn:#facc15; --bad:#fb7185;
      --chip:#0c1a3d; --chip-border:#203a7c;
      --minimap-top: 0px; /* set by JS based on header height */
      --header-h: 64px 
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:radial-gradient(1200px 700px at 50% -200px,#0b1633 0%,#050c1f 55%,#020614 100%);
      color:var(--ink); font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }
    .app{display:flex; flex-direction:column; min-height:100vh;}
    header{
      display:flex; align-items:center; justify-content:space-between; gap:5px;
      padding:14px 16px; background:linear-gradient(180deg,rgb(0, 76, 191),rgb(1, 23, 32));
      border-bottom:1px solid #13244f;
      position:sticky; top:0; z-index:10;
    }
    header h1{font-size:1.05rem; margin:0; font-weight:600; letter-spacing:0.2px}
    .nav{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    button{
      background:#102043; color:var(--ink); border:1px solid #1f3570; border-radius:10px; padding:8px 12px; cursor:pointer;
    }
    button:hover{background:#12265a}
    button[disabled]{opacity:.6; cursor:not-allowed}

    /* Mini-map */
    .minimap{
      position: sticky;
      top: var(--minimap-top);
      z-index: 9; /* just under header (which has z-index:10) */
      display:flex; gap:6px; align-items:center; flex-wrap:wrap;
      padding:8px 16px; border-top:1px solid #13244f; border-bottom:1px solid #13244f;
      background:linear-gradient(180deg,rgb(90, 208, 255),rgb(90, 208, 255));
    }
    .stage-chip{
      padding:4px 10px; border:1px solid var(--chip-border); border-radius:999px;
      background:var(--chip); font-size:.8rem; color:#bcd0ff; opacity:.75; white-space:nowrap;
    }
    .stage-chip.active{opacity:1; border-color:#3b66d1; color:#eaf2ff; box-shadow:0 0 0 1px rgba(90,209,255,.25) inset;}
    .progress{
      height:6px; flex:1; border-radius:999px; background:#0b1633; border:1px solid #1f3570; position:relative; min-width:140px;
    }
    .progress > .bar{
      position:absolute; top:-1px; left:-1px; height:calc(100% + 2px); width:0%;
      background:linear-gradient(90deg, #2a64ff, #5ad1ff);
      border-radius:999px;
    }


    main{ flex:1; display:flex; justify-content:center; padding:16px; align-items:stretch; }
/* Default: slides WITHOUT a hero get a single row */
.slide{
  min-height: calc(100vh - var(--header-h) - 32px); 
  width:min(1100px,100%);
  display:grid;
  grid-template-columns: 1.1fr .9fr;
  gap:16px;
  box-shadow:0 10px 30px rgba(0,0,0,.30);
  /* ✅ One row when there is no hero */
  grid-template-rows: 1fr;
}

/* ✅ If a slide HAS a hero, use two rows: hero + content */
.slide:has(> .hero){
  grid-template-rows: auto 1fr;
}
    .left, .right{min-height:380px; background:rgba(8,19,44,0.72); border:1px solid #182d61; border-radius:14px; overflow:hidden; position:relative}
    .panel{padding:14px 14px 10px 14px; height:100%; display:flex; flex-direction:column; gap:10px;}
    h2{margin:0 0 6px 0; font-size:1.05rem}
    p{margin:.25rem 0; color:var(--muted); line-height:1.35}
    ul,ol{margin:.4rem 0 .6rem 1.1rem; color:var(--muted)}
    label{font-size:.9rem; color:var(--muted)}
    select,input[type=range]{width:100%}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .chip{padding:4px 8px; border:1px solid #203a7c; border-radius:999px; font-size:.8rem; color:#bcd0ff; background:#0c1a3d}
    .canvasWrap{flex:1; border:1px dashed #253f85; border-radius:10px; overflow:hidden; background:#071332}
    canvas{display:block; width:100%; height:100%}
    .footerBar{display:flex; gap:10px; justify-content:flex-end; margin-top:8px; flex-wrap:wrap}
    .code{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; background:#0c1a3d; border:1px solid #203a7c; border-radius:8px; padding:8px; font-size:.88rem; color:#cfe1ff; overflow:auto}
    .note{font-size:.85rem; color:#93a9e8}
    .notes{
      margin-top:auto; border-top:1px dashed #243f86; padding-top:8px; font-size:.88rem; color:#cfe1ff; display:none;
      background:rgba(12,26,61,.35); border-radius:8px; padding:10px; line-height:1.35;
    }
    body.show-notes .notes{display:block}
    .notes .label{font-weight:600; color:#eaf2ff; opacity:.9; display:block; margin-bottom:4px;}

    @media (max-width: 980px){
      .slide{grid-template-columns: 1fr; }
      .left,.right{min-height:300px}
      .minimap{gap:8px}
    }
    [hidden]{display:none !important;}

    /* Hero */
    .slide > .hero{
      grid-column: 1 / -1;
      height: 200px;
      border-radius: 14px;
      /* border: 1px solid #182d61; */
      background: none;
      display: grid; place-items: center;
      position: relative; overflow: hidden; margin-bottom: 10px;
      box-shadow: 0 12px 30px rgba(0,0,0,.28);
    }
    .slide > .hero img{
      width: 100%; height: 100%; object-fit: contain;
    }
    .hero .caption{
      position:absolute; left:12px; bottom:10px;
      font-size:.9rem; color:#cfe1ff; opacity:.95;
      background: rgba(12,26,61,.55);
      border:1px solid #203a7c;
      padding:4px 8px; border-radius:8px;
    }

    /* Tooltip positioning tweaks: rely on left/top from JS, no transform */
    .encode-tip,.hidden-tip,.bp-tip{
      position:absolute;
      top:0;
      left:0;
      transform:none;
      background:#0c1a3d;
      border:1px solid #203a7c;
      padding:4px 6px;
      border-radius:6px;
      font-size:.8rem;
      color:#cfe1ff;
      display:none;
      pointer-events:none;
      white-space:nowrap;
      z-index:10; /* ensure above canvas */
    }

    .stageMap {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--panel);
      padding: 4px;
    }

    /* Amplitude gauge for neuron slide */
    .amp-gauge {
      height: 6px;
      border-radius: 999px;
      background: #0b1633;
      border: 1px solid #1f3570;
      position: relative;
      margin: 4px 0 10px 0;
    }
    .amp-gauge > .bar {
      position: absolute;
      top: -1px;
      left: -1px;
      height: calc(100% + 2px);
      width: 0%;
      /* color transitions from warn (yellow) to good (green) as amplitude grows */
      background: linear-gradient(90deg, var(--warn), var(--good));
      border-radius: 999px;
    }

  </style>
</head>
<body>
<div class="app">
  <header>
    <h1>Extreme Learning Machines — A Visual Primer for JS Engineers</h1>
    <div class="nav">
      <button id="prevBtn">◀ Back</button>
      <div class="chip" id="slideLabel">Slide 1 / 12</div>
      <button id="nextBtn">Next ▶</button>
      <button id="notesToggle" title="Show/Hide speaker notes">Notes</button>
    </div>
  </header>

  <!-- Mini-map -->
  <!-- <div class="minimap">
    <div class="stage-chip" data-stagechip="overview">Overview</div>
    <div class="stage-chip" data-stagechip="neuron">Neuron</div>
    <div class="stage-chip" data-stagechip="input">Vectorize</div>
    <div class="stage-chip" data-stagechip="backprop">Backprop</div>
    <div class="stage-chip" data-stagechip="huang">Huang</div>
    <div class="stage-chip" data-stagechip="grid">Random Grid</div>
    <div class="stage-chip" data-stagechip="gps">GPS/Pinv</div>
    <div class="stage-chip" data-stagechip="why">Why Random</div>
    <div class="stage-chip" data-stagechip="hidden">Hidden</div>
    <div class="stage-chip" data-stagechip="output">One-shot</div>
    <div class="stage-chip" data-stagechip="compare">Compare</div>
    <div class="stage-chip" data-stagechip="predict">Predict</div>
    <div class="progress"><div class="bar" id="progressBar"></div></div>
  </div> -->

  <main>

    <!-- SLIDE: OVERVIEW -->
    <section class="slide" id="slide0" data-stage="overview">
      <figure class="hero">
        <img src="images/ELM3-scaled.png" alt="ELM intro artwork" />
        <div class="caption">What we’ll cover</div>
      </figure>
      <div class="left">
        <div class="panel">
          <h2>What we’ll learn</h2>
          <ul>
            <li><strong>Neurons:</strong> weight, bias, activation function.</li>
            <li><strong>Vectorization:</strong> turning text into numeric features.</li>
            <li><strong>Why training is hard:</strong> too many parameters to tune.</li>
            <li><strong>Backprop (classic):</strong> iterative updates in loops.</li>
            <li><strong>ELM (shortcut):</strong> random hidden layer + one-shot solve.</li>
            <li><strong>Prediction:</strong> run the trained model on a sample.</li>
          </ul>
          <p class="note">We’ll keep it JavaScript-friendly: sliders, canvases, and small code snippets.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Open with the promise: ELMs let us train in seconds. Point at the minimap and set expectations for the flow.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Roadmap</h2>
          <ol>
            <li>Intro</li>
            <li>Neuron demo</li>
            <li>Text → vector</li>
            <li>Backprop loops</li>
            <li>Huang’s question</li>
            <li>Random grid intuition</li>
            <li>GPS/pseudoinverse</li>
            <li>Why randomness helps</li>
            <li>Random hidden &amp; project</li>
            <li>ELM one-shot training</li>
            <li>Backprop vs ELM</li>
            <li>Prediction</li>
          </ol>
          <div class="notes"><span class="label">Speaker notes</span>
            Mention we’ll avoid heavy math; we’ll visualize the ideas and keep code minimal.
          </div>
        </div>
      </div>
    </section>

    <!-- SLIDE: NEURON DEMO -->
    <section class="slide" id="slide1" data-stage="neuron">
      <div class="left">
        <div class="panel">
          <h2>Neuron demo</h2>
          <p>Adjust <em>w</em> and <em>b</em>, choose an activation, and watch <code>y = g(w·x + b)</code>.</p>
          <div class="row">
            <div style="flex:1">
              <label>Activation</label>
              <select id="actSelect">
                <option value="relu">ReLU</option>
                <option value="leakyRelu">LeakyReLU</option>
                <option value="sigmoid">Sigmoid</option>
                <option value="tanh">tanh</option>
              </select>
            </div>
            <div class="chip">Live chart</div>
          </div>
          <div class="kv"><label>Weight (w)</label><span id="wVal">1.00</span></div>
          <input id="wRange" type="range" min="-5" max="5" step="0.05" value="1">
          <div class="kv"><label>Bias (b)</label><span id="bVal">0.00</span></div>
          <input id="bRange" type="range" min="-5" max="5" step="0.05" value="0">
          
          <!-- Pre‑activation amplitude elements (already in place) -->
          <div class="kv"><label>Pre‑activation amplitude</label><span id="ampVal">0.00</span></div>
          <div class="amp-gauge"><div class="bar" id="ampBar"></div></div>

          <!-- NEW: Post‑activation amplitude elements -->
          <div class="kv"><label>Post‑activation amplitude</label><span id="postAmpVal">0.00</span></div>
          <div class="amp-gauge"><div class="bar" id="postAmpBar"></div></div>

          <div class="canvasWrap" style="height:260px"><canvas id="neuronCanvas"></canvas></div>
          <div class="note">“Affine” = compute <code>z = w·x + b</code>, then apply <code>g(z)</code>.</div>
          <div class="notes"><span class="label">Speaker notes</span>
            Try negative w; compare ReLU vs tanh; highlight clipping vs smoothness.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Try</h2>
          <ul>
            <li>Set <strong>w = -2</strong>, <strong>b = 0.5</strong></li>
            <li>Toggle ReLU ↔︎ tanh and observe shape changes</li>
          </ul>
          <div class="code"><pre>// y = g(w·x + b)
const z = w * x + b;
const y = activation(z);</pre></div>

<ul>
  <li>A neuron takes inputs, multiplies by weights, adds bias.</li>
  <li>The sum passes through an activation function.</li>
  <li>Weights and bias are the parameters that control output.</li>
</ul>
          <div class="notes"><span class="label">Speaker notes</span>
            
          </div>
        </div>
      </div>
    </section>


  <!-- SLIDE: VECTORIZATION -->
    <section class="slide" id="slide2" data-stage="input">
      <div class="left">
        <div class="panel">
          <h2>Vectorization (text → numbers)</h2>
          <p>
            Select a row and choose how you want to encode it. We’ll convert the text
            into a numeric feature vector and draw a mini heatmap of those features.
          </p>

          <!-- NEW: Encoding method and feature-limit controls -->
          <div class="row">
            <span class="chip">Encoding</span>
            <select id="encodingSelect" style="flex:1">
              <option value="tfidf">TF‑IDF</option>
              <option value="bow">Bag‑of‑Words</option>
              <option value="isolated">Isolated</option>
            </select>
          </div>
          <div class="row">
            <span class="chip">Max features</span>
            <input id="featureLimit" type="range" min="16" max="256" step="16" value="128" style="flex:1">
            <span class="note" id="featureLimitVal">128</span>
          </div>

          <div class="row">
            <select id="rowSelect" style="flex:1"></select>
            <button id="encodeBtn">Encode text</button>
          </div>

          <div class="canvasWrap" style="height:260px; position:relative">
            <canvas id="encodeCanvas"></canvas>
          </div>
          <div id="tokensOut" class="code" style="min-height:80px"></div>

          <div class="notes">
            <span class="label">Speaker notes</span>
            Explain that different encodings (Bag‑of‑Words vs TF‑IDF vs isolated counts) can change how much weight each token gets.  Encourage the audience to try each method and adjust the feature‑limit slider to see how the heatmap changes.  Remind them that any numeric encoding works for ELMs.
          </div>
        </div>
      </div>

      <div class="right">
        <div class="panel">
          <h2>Plain English</h2>
          <p>
            Vectorization turns unstructured text into a fixed‑length numeric vector so a neural net can process it.
          </p>
          <p>
            <strong>Bag‑of‑Words:</strong> each word becomes a feature and the value is its count; this simple tally ignores word order and context:contentReference[oaicite:0]{index=0}.
          </p>
          <p>
            <strong>TF‑IDF:</strong> weighs word frequency by inverse document frequency so common words are down‑weighted; it emphasises rare yet distinctive words:contentReference[oaicite:1]{index=1}.
          </p>
          <p>
            <strong>ELM flexibility:</strong> ELM only needs a numeric vector, so you can use any reasonable encoder (BoW, TF‑IDF or even embeddings).  The hidden layer’s random projection works the same no matter which features you choose.
          </p>
        </div>
      </div>
    </section>

    <!-- SLIDE: WHY HAND TUNING IS HARD → BACKPROP -->
    <section class="slide" id="slideBP" data-stage="backprop">
      <div class="left">
        <div class="panel">
          <h2>Why manual tuning doesn’t scale</h2>
          <p>Real networks have many parameters—impossible to tweak by hand.</p>
          <p><strong>Backpropagation</strong> automates tuning in loops: measure error → nudge weights → repeat.</p>
          <div class="kv"><label>Learning rate</label><span id="bpLRVal">0.20</span></div>
          <input id="bpLR" type="range" min="0.01" max="1" step="0.01" value="0.20">
          <div class="canvasWrap" style="height:260px; position:relative">
            <canvas id="bpCanvas"></canvas>
          </div>
          <div class="note">Visual mock: weights wiggle; loss trends down.</div>
          <div class="notes"><span class="label">Speaker notes</span>
            Call out “too high LR = noisy; too low = slow.” Set up the contrast with ELM.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>What to look for</h2>
          <ul>
            <li>Left heatmap: hidden weights changing</li>
            <li>Right chart: loss trending down</li>
            <li>LR too high → noisy; too low → sluggish</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- SLIDE: HUANG'S QUESTION -->
    <section class="slide" id="slideHuang" data-stage="huang">
            <figure class="hero">
        <img src="images/bold-question-final.png" alt="ELM intro artwork" />
        <div class="caption">The Bold Question</div>
      </figure>
      <div class="left">
        <div class="panel">
          <h2>Then along comes Guang-Bin Huang</h2>
          <p><em>What if we didn’t train the hidden layers at all?</em></p>
          <p>To many engineers, that sounds like shipping production code without unit tests. Hidden layers are where the magic happens—so why skip training them?</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Pause, look around. Let the “no hidden training” line sit. Invite skepticism.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>The insight</h2>
          <p>Randomize the hidden layer once (weights &amp; biases), then never touch it.</p>
          <p>Focus all effort on solving the output layer in one step with the Moore–Penrose pseudoinverse.</p>
          <p class="note">Minutes or hours of loops → seconds.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE: RANDOM GRID ANALOGY -->
    <section class="slide" id="slideGrid" data-stage="grid">
      <figure class="hero"><div class="caption">Random coordinates, useful structure</div></figure>
      <div class="left">
        <div class="panel">
          <h2>The city from above</h2>
          <p>From a skyscraper, the city looks messy—twisting streets, odd angles. Hard to give directions.</p>
          <p>Drop a <strong>random grid</strong> on top. It won’t match perfectly, but now you can say: “Café at row 3, col 5.” The grid isn’t smart—but it’s a reference system.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Gesture with hands as a grid overlay; “it’s not perfect, it’s useful”.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>ELM mapping</h2>
          <p>The hidden layer is that grid: it projects messy, high-dimensional data into random coordinates.</p>
          <p><code>H = g(X·W + b)</code></p>
          <p class="note">Once you have coordinates, organization gets simpler.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE: GPS / PSEUDOINVERSE -->
    <section class="slide" id="slideGPS" data-stage="gps">
      <figure class="hero"><div class="caption">One solve, like GPS routing</div></figure>
      <div class="left">
        <div class="panel">
          <h2>Output layer as GPS</h2>
          <p>With coordinates in hand, navigation is easy: straight lines in grid space. The output layer is the GPS: map random coordinates to labels in one exact step.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Promise: no epochs. We’ll compute β in a single calculation.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>The math idea</h2>
          <p>Use the <strong>Moore–Penrose pseudoinverse</strong> to solve <code>Hβ ≈ Y</code>.</p>
          <p>Think of it like <code>Array.prototype.reduce()</code> for optimization: push inputs &amp; labels through, get the best output weights <code>β</code>.</p>
          <p class="note">No gradient descent loops. One solve.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE: WHY RANDOMNESS WORKS -->
    <section class="slide" id="slideWhy" data-stage="why">
      <figure class="hero"><div class="caption">Unfold the data</div></figure>
      <div class="left">
        <div class="panel">
          <h2>Why randomness helps</h2>
          <p>Raw input space is often not linearly separable. Random projection to a higher-dimensional space can make separation easier—like unfolding a crumpled paper ball onto a plane.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            “Higher dimension → simpler boundaries.” Mention regularization briefly.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>ELM recipe</h2>
          <ol>
            <li>Project inputs with a randomized hidden layer to get <code>H</code>.</li>
            <li>Solve a linear model once for <code>β</code> so <code>Hβ ≈ Y</code>.</li>
          </ol>
          <p class="note">Surprisingly strong with enough hidden units + sensible ridge.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE: HIDDEN LAYER (random W,b + project H) -->
    <section class="slide" id="slideHidden" data-stage="hidden">
      <div class="left">
        <div class="panel">
          <h2>Hidden layer (Random &amp; Project)</h2>
          <p>Random projection: <code>H = g(X·W + b)</code>. Reseed the hidden layer; project the currently encoded row.</p>
          <div class="row">
            <span class="chip">Hidden size</span>
            <input id="hiddenSizeHL" type="range" min="4" max="1024" step="1" value="32" style="flex:1">
            <span class="note" id="hiddenSizeHLVal">32</span>
            <button id="shuffleBtnHL" title="Reseed W,b">Reseed hidden</button>
            <button id="previewHBtnHL" title="Project current x">Project H</button>
          </div>
          <div class="canvasWrap" style="height:260px; position:relative">
            <canvas id="hiddenCanvas"></canvas>
            <div class="hidden-tip"></div>
          </div>
          <div id="WPreview" class="code" style="min-height:80px"></div>
          <div class="notes"><span class="label">Speaker notes</span>
            Show W heatmap, then project a row to visualize H bars.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>What you’re seeing</h2>
          <p>Heatmap: rows = hidden neurons; cols = input features; color = sign &amp; magnitude of <code>W[i,j]</code>. Bars on right show <code>H = g(Wx + b)</code> for the selected text.</p>
          <p class="note">Tip: encode on the previous slide, then project.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE: ELM TRAINING (ONE SHOT) -->
    <section class="slide" id="slide4" data-stage="output">
      <div class="left">
        <div class="panel">
          <h2>ELM: random hidden + one-shot solve</h2>
          <p>We solve <code>Hβ ≈ Y</code> once (pseudoinverse / ridge). No loops.</p>
          <div class="row">
            <button id="trainBtn">Train (one shot)</button>
            <span class="chip">Hidden size</span>
            <input id="hiddenSize" type="range" min="4" max="1024" step="1" value="32" style="flex:1">
            <span class="note" id="hiddenSizeVal">32</span>
            <span style="flex:1"></span>
            <button id="downloadBtn" title="Save W,b,β and basis">Export model</button>
            <button id="resetBtn" title="Clear model & basis">Clear &amp; reset</button>
          </div>
          <div id="solveOut" class="code" style="min-height:100px">Waiting…</div>
          <div class="canvasWrap" style="height:220px">
            <canvas id="betaCanvas"></canvas>
          </div>
          <div class="notes"><span class="label">Speaker notes</span>
            Call out dimensions H (n×h), Y (n×k), β (h×k). Mention ridge.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Plain English</h2>
          <p>Random hidden features give coordinates. We draw a straight separator there. Done.</p>
          <p class="note">The shortcut: one solve vs many backprop loops.</p>
        </div>
      </div>
    </section>

    <!-- SLIDE: BACKPROP VS ELM -->
    <section class="slide" id="slideCompare" data-stage="compare">
      <figure class="hero"><div class="caption">Two different mindsets</div></figure>
      <div class="left">
        <div class="panel">
          <h2>Backprop</h2>
          <p>Like sculpting a custom key for a lock: chip, test, adjust—many iterations until it fits.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Emphasize control/fidelity, but cost is time and tuning.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>ELM</h2>
          <p>Like trying a keyring of random keys (random hidden features). One fits; keep it by solving the output weights once.</p>
          <div class="notes"><span class="label">Speaker notes</span>
            Great default for fast baselines, prototyping, or small/medium tasks.
          </div>
        </div>
      </div>
    </section>

    <!-- SLIDE: PREDICTION -->
    <section class="slide" id="slidePred" data-stage="predict">
      <div class="left">
        <div class="panel">
          <h2>Prediction demo</h2>
          <p>Pick a row and run the trained model.</p>
          <div class="row">
            <select id="predRowSelect" style="flex:1"></select>
            <button id="predictBtn" title="Train first" disabled>Predict</button>
          </div>
          <div id="predOut" class="code" style="min-height:120px">Train on the previous slide, then predict.</div>
          <div class="notes"><span class="label">Speaker notes</span>
            Read out Predicted vs Truth and probabilities; note ✓/✗.
          </div>
        </div>
      </div>
      <div class="right">
        <div class="panel">
          <h2>Reading the result</h2>
          <p><strong>Predicted label</strong>, ground truth, and per-class probabilities.</p>
          <p class="note">If the truth exists in the sample, we’ll mark ✓ or ✗.</p>
        </div>
      </div>
    </section>

  </main>

  <div style="padding:8px 16px; display:flex; gap:8px; align-items:center; justify-content:space-between;">
    <div id="status" class="note">Worker: <span id="workerStatus">connecting…</span></div>
    <!--<div class="footerBar">
       Buttons auto-generated by JS 
    </div>-->
  </div>
</div>

<script src="elm-demo.js"></script>
</body>
</html>
